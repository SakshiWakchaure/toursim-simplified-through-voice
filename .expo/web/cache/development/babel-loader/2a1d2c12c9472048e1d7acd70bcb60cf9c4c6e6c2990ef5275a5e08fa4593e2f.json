{"ast":null,"code":"import _slicedToArray from \"@babel/runtime/helpers/slicedToArray\";\nimport NativeReanimatedModule from \"./NativeReanimated\";\nimport { shouldBeUseWeb } from \"./PlatformChecker\";\nimport { registerWorkletStackDetails } from \"./errors\";\nvar USE_STUB_IMPLEMENTATION = shouldBeUseWeb();\nvar _shareableCache = new WeakMap();\nvar _shareableFlag = Symbol('shareable flag');\nvar MAGIC_KEY = 'REANIMATED_MAGIC_KEY';\nfunction isHostObject(value) {\n  return MAGIC_KEY in value;\n}\nexport function registerShareableMapping(shareable, shareableRef) {\n  if (USE_STUB_IMPLEMENTATION) {\n    return;\n  }\n  _shareableCache.set(shareable, shareableRef || _shareableFlag);\n}\nexport function makeShareableCloneRecursive(value) {\n  var shouldPersistRemote = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;\n  if (USE_STUB_IMPLEMENTATION) {\n    return value;\n  }\n  var type = typeof value;\n  if ((type === 'object' || type === 'function') && value !== null) {\n    var cached = _shareableCache.get(value);\n    if (cached === _shareableFlag) {\n      return value;\n    } else if (cached !== undefined) {\n      return cached;\n    } else {\n      var toAdapt;\n      if (Array.isArray(value)) {\n        toAdapt = value.map(function (element) {\n          return makeShareableCloneRecursive(element);\n        });\n      } else if (type === 'function' && value.__workletHash === undefined) {\n        toAdapt = value;\n      } else if (isHostObject(value)) {\n        toAdapt = value;\n      } else {\n        toAdapt = {};\n        if (value.__workletHash !== undefined) {\n          if (__DEV__) {\n            registerWorkletStackDetails(value.__workletHash, value.__stackDetails);\n            delete value.__stackDetails;\n          }\n          toAdapt.__initData = makeShareableCloneRecursive(value.__initData, true);\n          delete value.__initData;\n        }\n        for (var _ref of Object.entries(value)) {\n          var _ref2 = _slicedToArray(_ref, 2);\n          var key = _ref2[0];\n          var element = _ref2[1];\n          toAdapt[key] = makeShareableCloneRecursive(element);\n        }\n      }\n      if (__DEV__) {\n        Object.freeze(value);\n      }\n      var adopted = NativeReanimatedModule.makeShareableClone(toAdapt, shouldPersistRemote);\n      _shareableCache.set(value, adopted);\n      _shareableCache.set(adopted, _shareableFlag);\n      return adopted;\n    }\n  }\n  return NativeReanimatedModule.makeShareableClone(value, shouldPersistRemote);\n}\nexport function makeShareableCloneOnUIRecursive(value) {\n  'worklet';\n\n  if (USE_STUB_IMPLEMENTATION) {\n    return value;\n  }\n  function cloneRecursive(value) {\n    var type = typeof value;\n    if ((type === 'object' || type === 'function') && value !== null) {\n      var toAdapt;\n      if (Array.isArray(value)) {\n        toAdapt = value.map(function (element) {\n          return cloneRecursive(element);\n        });\n      } else {\n        toAdapt = {};\n        for (var _ref3 of Object.entries(value)) {\n          var _ref4 = _slicedToArray(_ref3, 2);\n          var key = _ref4[0];\n          var element = _ref4[1];\n          toAdapt[key] = cloneRecursive(element);\n        }\n      }\n      if (__DEV__) {\n        Object.freeze(value);\n      }\n      return _makeShareableClone(toAdapt);\n    }\n    return _makeShareableClone(value);\n  }\n  return cloneRecursive(value);\n}\nexport function makeShareable(value) {\n  if (USE_STUB_IMPLEMENTATION) {\n    return value;\n  }\n  var handle = makeShareableCloneRecursive({\n    __init: function __init() {\n      'worklet';\n\n      return value;\n    }\n  });\n  registerShareableMapping(value, handle);\n  return value;\n}","map":{"version":3,"names":["NativeReanimatedModule","shouldBeUseWeb","registerWorkletStackDetails","USE_STUB_IMPLEMENTATION","_shareableCache","WeakMap","_shareableFlag","Symbol","MAGIC_KEY","isHostObject","value","registerShareableMapping","shareable","shareableRef","set","makeShareableCloneRecursive","shouldPersistRemote","arguments","length","undefined","type","cached","get","toAdapt","Array","isArray","map","element","__workletHash","__DEV__","__stackDetails","__initData","_ref","Object","entries","_ref2","_slicedToArray","key","freeze","adopted","makeShareableClone","makeShareableCloneOnUIRecursive","cloneRecursive","_ref3","_ref4","_makeShareableClone","makeShareable","handle","__init"],"sources":["D:\\xampp\\htdocs\\gotravel1\\toursim-simplified-through-voice-master\\toursim-simplified-through-voice-master\\node_modules\\react-native-reanimated\\lib\\module\\reanimated2\\shareables.ts"],"sourcesContent":["import NativeReanimatedModule from './NativeReanimated';\nimport { ShareableRef } from './commonTypes';\nimport { shouldBeUseWeb } from './PlatformChecker';\nimport { registerWorkletStackDetails } from './errors';\n\n// for web/chrome debugger/jest environments this file provides a stub implementation\n// where no shareable references are used. Instead, the objects themselves are used\n// instead of shareable references, because of the fact that we don't have to deal with\n// runnning the code on separate VMs.\nconst USE_STUB_IMPLEMENTATION = shouldBeUseWeb();\n\nconst _shareableCache = new WeakMap<\n  Record<string, unknown>,\n  ShareableRef<any> | symbol\n>();\n// the below symbol is used to represent a mapping from the value to itself\n// this is used to allow for a converted shareable to be passed to makeShareableClone\nconst _shareableFlag = Symbol('shareable flag');\n\nconst MAGIC_KEY = 'REANIMATED_MAGIC_KEY';\n\nfunction isHostObject(value: any): boolean {\n  // We could use JSI to determine whether an object is a host object, however\n  // the below workaround works well and is way faster than an additional JSI call.\n  // We use the fact that host objects have broken implementation of `hasOwnProperty`\n  // and hence return true for all `in` checks regardless of the key we ask for.\n  return MAGIC_KEY in value;\n}\n\nexport function registerShareableMapping(\n  shareable: any,\n  shareableRef?: ShareableRef<any>\n): void {\n  if (USE_STUB_IMPLEMENTATION) {\n    return;\n  }\n  _shareableCache.set(shareable, shareableRef || _shareableFlag);\n}\n\nexport function makeShareableCloneRecursive<T>(\n  value: any,\n  shouldPersistRemote = false\n): ShareableRef<T> {\n  if (USE_STUB_IMPLEMENTATION) {\n    return value;\n  }\n  // This one actually may be worth to be moved to c++, we also need similar logic to run on the UI thread\n  const type = typeof value;\n  if ((type === 'object' || type === 'function') && value !== null) {\n    const cached = _shareableCache.get(value);\n    if (cached === _shareableFlag) {\n      return value;\n    } else if (cached !== undefined) {\n      return cached as ShareableRef<T>;\n    } else {\n      let toAdapt: any;\n      if (Array.isArray(value)) {\n        toAdapt = value.map((element) => makeShareableCloneRecursive(element));\n      } else if (type === 'function' && value.__workletHash === undefined) {\n        // this is a remote function\n        toAdapt = value;\n      } else if (isHostObject(value)) {\n        // for host objects we pass the reference to the object as shareable and\n        // then recreate new host object wrapping the same instance on the UI thread.\n        // there is no point of iterating over keys as we do for regular objects.\n        toAdapt = value;\n      } else {\n        toAdapt = {};\n        if (value.__workletHash !== undefined) {\n          // we are converting a worklet\n          if (__DEV__) {\n            registerWorkletStackDetails(\n              value.__workletHash,\n              value.__stackDetails\n            );\n            delete value.__stackDetails;\n          }\n          // to save on transferring static __initData field of worklet structure\n          // we request shareable value to persist its UI counterpart. This means\n          // that the __initData field that contains long strings represeting the\n          // worklet code, source map, and location, will always be\n          // serialized/deserialized once.\n          toAdapt.__initData = makeShareableCloneRecursive(\n            value.__initData,\n            true\n          );\n          delete value.__initData;\n        }\n\n        for (const [key, element] of Object.entries(value)) {\n          toAdapt[key] = makeShareableCloneRecursive(element);\n        }\n      }\n      if (__DEV__) {\n        // we freeze objects that are transformed to shareable. This should help\n        // detect issues when someone modifies data after it's been converted to\n        // shareable. Meaning that they may be doing a faulty assumption in their\n        // code expecting that the updates are going to automatically populate to\n        // the object sent to the UI thread. If the user really wants some objects\n        // to be mutable they should use shared values instead.\n        Object.freeze(value);\n      }\n      const adopted = NativeReanimatedModule.makeShareableClone(\n        toAdapt,\n        shouldPersistRemote\n      );\n      _shareableCache.set(value, adopted);\n      _shareableCache.set(adopted, _shareableFlag);\n      return adopted;\n    }\n  }\n  return NativeReanimatedModule.makeShareableClone(value, shouldPersistRemote);\n}\n\nexport function makeShareableCloneOnUIRecursive<T>(value: T): ShareableRef<T> {\n  'worklet';\n  if (USE_STUB_IMPLEMENTATION) {\n    // @ts-ignore web is an interesting place where we don't run a secondary VM on the UI thread\n    // see more details in the comment where USE_STUB_IMPLEMENTATION is defined.\n    return value;\n  }\n  function cloneRecursive<T>(value: T): ShareableRef<T> {\n    const type = typeof value;\n    if ((type === 'object' || type === 'function') && value !== null) {\n      let toAdapt: any;\n      if (Array.isArray(value)) {\n        toAdapt = value.map((element) => cloneRecursive(element));\n      } else {\n        toAdapt = {};\n        for (const [key, element] of Object.entries(value)) {\n          toAdapt[key] = cloneRecursive(element);\n        }\n      }\n      if (__DEV__) {\n        // See the reasoning behind freezing in the other comment above.\n        Object.freeze(value);\n      }\n      return _makeShareableClone(toAdapt);\n    }\n    return _makeShareableClone(value);\n  }\n  return cloneRecursive(value);\n}\n\nexport function makeShareable<T>(value: T): T {\n  if (USE_STUB_IMPLEMENTATION) {\n    return value;\n  }\n  const handle = makeShareableCloneRecursive({\n    __init: () => {\n      'worklet';\n      return value;\n    },\n  });\n  registerShareableMapping(value, handle);\n  return value;\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}